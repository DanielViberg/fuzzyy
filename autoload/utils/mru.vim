if exists('fuzzyy_mru_loaded')
  finish
endif
let fuzzyy_mru_loaded = 1

" MRU configuration variables {{{1
" Maximum number of file names stored in the MRU list
let MRU_Max_Entries = 100

" Files to exclude from the MRU list
let MRU_Exclude_Files = ''

" Files to include in the MRU list
let MRU_Include_Files = ''

if !exists('g:MRU_File')
  if has('unix') || has('macunix')
    let s:MRU_File = $HOME . '/.vim_mru_files'
  else
    let s:MRU_File = $VIM . '/_vim_mru_files'
    if has('win32')
      " MS-Windows
      if !empty($USERPROFILE)
	let s:MRU_File = $USERPROFILE . '\_vim_mru_files'
      endif
    endif
  endif
else
  let s:MRU_File = expand(g:MRU_File)
endif

" Controls whether the alternate file (:help alternate-file) is set when the
" plugin is loaded to the first file in the MRU list. Default is to set the
" alternate file.
if !exists('MRU_Set_Alternate_File')
  let MRU_Set_Alternate_File = 0
endif

" Format of the file names displayed in the MRU window.
" The default is to display the filename followed by the complete path to the
" file in parenthesis. This variable controls the expressions used to format
" and parse the path. This can be changed to display the filenames in a
" different format. The 'formatter' specifies how to split/format the filename
" and 'parser' specifies how to read the filename back; 'syntax' matches the
" part to be highlighted.
if !exists('MRU_Filename_Format')
  let MRU_Filename_Format = {
	\ 'formatter': 'fnamemodify(v:val, ":t") . " (" . v:val . ")"',
	\ 'parser': '(\zs.*\ze)',
	\ 'syntax': '^.\{-}\ze('
	\}
endif

let s:MRU_buf_name = '-RecentFiles-'

" Control to temporarily lock the MRU list. Used to prevent files from
" getting added to the MRU list when the ':vimgrep' command is executed.
let s:mru_list_locked = 0

" MRU_LoadList                          {{{1
" Loads the latest list of file names from the MRU file
func! s:MRU_LoadList() abort
  " If the MRU file is present, then load the list of filenames. Otherwise
  " start with an empty list.
  if filereadable(s:MRU_File)
    let s:MRU_files = readfile(s:MRU_File)
    if empty(s:MRU_files)
      " empty MRU file
      let s:MRU_files = []
    elseif s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
      " Generated by the previous version of the MRU plugin.
      " Discard the list.
      let s:MRU_files = []
    elseif s:MRU_files[0] =~# '^#'
      " Remove the comment line
      call remove(s:MRU_files, 0)
    else
      " Unsupported format
      let s:MRU_files = []
    endif
  else
    let s:MRU_files = []
  endif

endfunc

" MRU_SaveList                          {{{1
" Saves the MRU file names to the MRU file
func! s:MRU_SaveList() abort
  let l = []
  call add(l, '# Most recently edited files in Vim (version 3.0)')
  call extend(l, s:MRU_files)
  call writefile(l, s:MRU_File)
endfunc

" MRU_AddFile                           {{{1
" Adds a file to the MRU file list
"   acmd_bufnr - Buffer number of the file to add
func! s:MRU_AddFile(acmd_bufnr) abort
  if s:mru_list_locked
    " MRU list is currently locked
    return
  endif

  " Get the full path to the filename
  let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
  if empty(fname)
    return
  endif

  " Skip temporary buffers with buftype set. The buftype is set for buffers
  " used by plugins.
  if !empty(&buftype)
    return
  endif

  if !empty(g:MRU_Include_Files)
    " If MRU_Include_Files is set, include only files matching the
    " specified pattern
    if fname !~# g:MRU_Include_Files
      return
    endif
  endif

  if !empty(g:MRU_Exclude_Files)
    " Do not add files matching the pattern specified in the
    " MRU_Exclude_Files to the MRU list
    if fname =~# g:MRU_Exclude_Files
      return
    endif
  endif

  " If the filename is not already present in the MRU list and is not
  " readable then ignore it
  let idx = index(s:MRU_files, fname)
  if idx == -1
    if !filereadable(fname)
      " File is not readable and is not in the MRU list
      return
    endif
  endif

  " Load the latest MRU file list
  call s:MRU_LoadList()

  " Remove the new file name from the existing MRU list (if already present)
  call filter(s:MRU_files, 'v:val !=# fname')

  " Add the new file list to the beginning of the updated old file list
  call insert(s:MRU_files, fname, 0)

  " Trim the list
  if len(s:MRU_files) > g:MRU_Max_Entries
    call remove(s:MRU_files, g:MRU_Max_Entries, -1)
  endif

  " Save the updated MRU list
  call s:MRU_SaveList()

endfunc

" MRU_escape_filename                   {{{1
" Escape special characters in a filename. Special characters in file names
" that should be escaped (for security reasons)
let s:esc_filename_chars = ' *?[{`$%#"|!<>();&' . "'\t\n"
func! s:MRU_escape_filename(fname) abort
  if exists('*fnameescape')
    return fnameescape(a:fname)
  else
    return escape(a:fname, s:esc_filename_chars)
  endif
endfunc

" MRU_Warn_Msg                          {{{1
" Display a warning message
func! s:MRU_Warn_Msg(msg) abort
  echohl WarningMsg
  echo a:msg
  echohl None
endfunc

" MRU_Refresh    {{{1
" Remove non-existing files from the MRU list
func s:MRU_Refresh()
  call filter(s:MRU_files, 'filereadable(v:val)')
  call s:MRU_SaveList()
endfunc

" MRU_Delete_From_List    {{{1
" remove the entry under cursor in the MRU window from the MRU list
func s:MRU_Delete_From_List()
  call filter(s:MRU_files,
	\ 'v:val != matchstr(getline("."), g:MRU_Filename_Format.parser)')
  setlocal modifiable
  del _
  setlocal nomodifiable
  call s:MRU_SaveList()
endfunc

" Return the list of file names in the MRU list {{{1
func MruGetFiles(...)
  " Load the latest MRU list
  call s:MRU_LoadList()
  return copy(s:MRU_files)
endfunc

" Load the MRU list on plugin startup
call s:MRU_LoadList()

" Set the first entry in the MRU list as the alternate file
" Credit to Martin Roa Villescas (https://github.com/mroavi) for the patch.
" bufadd() is available starting from Vim 8.1.1610
if g:MRU_Set_Alternate_File == 1 &&
      \ (v:version >= 802 || has('patch-8.1.1610') || has('nvim'))
  if !empty(s:MRU_files)
    let first_mru_file = s:MRU_files[0]
    if filereadable(first_mru_file)
      call bufadd(first_mru_file)
      let @# = first_mru_file
    endif
  endif
endif

func! utils#mru#init()
  " MRU autocommands {{{1
  " Autocommands to update the most recently used files
  augroup MRUAutoCmds
    au!
    autocmd BufRead * call s:MRU_AddFile(expand('<abuf>'))
    autocmd BufWritePost * call s:MRU_AddFile(expand('<abuf>'))
    autocmd BufEnter * call s:MRU_AddFile(expand('<abuf>'))

    " The ':vimgrep' command adds all the files searched to the buffer list.
    " This also modifies the MRU list, even though the user didn't edit the
    " files. Use the following autocmds to prevent this.
    autocmd QuickFixCmdPre *vimgrep* let s:mru_list_locked = 1
    autocmd QuickFixCmdPost *vimgrep* let s:mru_list_locked = 0
  augroup END
endfunc
